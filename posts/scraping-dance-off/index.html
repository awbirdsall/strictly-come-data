<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Strictly Come Data  | Scraping Dance-Off Data from Wikipedia</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.40.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/strictly-come-data/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Scraping Dance-Off Data from Wikipedia" />
<meta property="og:description" content="Now that I have two weeks of predicting Strictly scores under my belt, I&rsquo;m interested in looking at who gets voted into the dance-off. For example, a 2016 article in The Guardian by Julia Carter and Richard McManus reported that
 &ldquo;after controlling for where the couple have come in the judges’ scoring, an ethnic minority celebrity is statistically significantly more likely to be in the bottom two and therefore to have received a lower public vote." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://awbirdsall.github.io/strictly-come-data/posts/scraping-dance-off/" />



<meta property="article:published_time" content="2018-10-21T18:48:40-04:00"/>

<meta property="article:modified_time" content="2018-10-21T18:48:40-04:00"/>











<meta itemprop="name" content="Scraping Dance-Off Data from Wikipedia">
<meta itemprop="description" content="Now that I have two weeks of predicting Strictly scores under my belt, I&rsquo;m interested in looking at who gets voted into the dance-off. For example, a 2016 article in The Guardian by Julia Carter and Richard McManus reported that
 &ldquo;after controlling for where the couple have come in the judges’ scoring, an ethnic minority celebrity is statistically significantly more likely to be in the bottom two and therefore to have received a lower public vote.">


<meta itemprop="datePublished" content="2018-10-21T18:48:40-04:00" />
<meta itemprop="dateModified" content="2018-10-21T18:48:40-04:00" />
<meta itemprop="wordCount" content="1287">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Scraping Dance-Off Data from Wikipedia"/>
<meta name="twitter:description" content="Now that I have two weeks of predicting Strictly scores under my belt, I&rsquo;m interested in looking at who gets voted into the dance-off. For example, a 2016 article in The Guardian by Julia Carter and Richard McManus reported that
 &ldquo;after controlling for where the couple have come in the judges’ scoring, an ethnic minority celebrity is statistically significantly more likely to be in the bottom two and therefore to have received a lower public vote."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://awbirdsall.github.io/strictly-come-data/" class="f3 fw2 hover-white no-underline white-90 dib">
      Strictly Come Data
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Scraping Dance-Off Data from Wikipedia</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2018-10-21T18:48:40-04:00">October 21, 2018</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Now that I have <a href="../score-evaluation/">two</a> <a href="../week-5-scores">weeks</a> of predicting Strictly scores under my belt, I&rsquo;m interested in looking at who gets voted into the dance-off. For example, <a href="https://www.theguardian.com/commentisfree/2016/dec/16/black-strictly-come-dancing">a 2016 article</a> in <em>The Guardian</em> by Julia Carter and Richard McManus reported that</p>

<blockquote>
<p>&ldquo;after controlling for where the couple have come in the judges’ scoring, an ethnic minority celebrity is statistically significantly more likely to be in the bottom two and therefore to have received a lower public vote.&rdquo;</p>
</blockquote>

<p>In a study, they found a 71% increase in the likelihood of being in the dance-off for non-white celebrities, and 83% for black women—strikingly large effects. It doesn&rsquo;t seem like a more detailed description of their analysis has been published, so I am interested in whether I could reproduce their results.</p>

<p>It would also be interesting to look at other possible predictive variables: e.g., size of social media following, age, hometown, or type of celebrity.</p>

<p>Because the BBC has never made information about the public voting results public, the only outcome that can be assessed is the identity of the two contestants in the dance-off each week.</p>

<p>The first step is gathering the data. Unfortunately, <a href="http://www.ultimatestrictly.com/">Ultimate Strictly</a> doesn&rsquo;t provide a full set of dance-off data. Instead, I scraped the data from the voluminous Strictly series-specific Wikipedia pages.</p>

<p>The Wikipedia pages do provide dance-off data for all series, but dance-off information is only summarized a full series at a time by the background color of cells in each series&rsquo; &ldquo;Scoring chart&rdquo; (e.g., <a href="https://en.wikipedia.org/wiki/Strictly_Come_Dancing_(series_15)#Scoring_chart">for Series 15</a>).</p>

<p>Despite this inconvenience, the structure of the Wikipedia pages are uniform enough that I was able to construct a Python script to scrape the couples in each week&rsquo;s dance-off. As an overview, the steps were to:</p>

<ul>
<li>Use <code>requests</code> to download the html.</li>
<li>Use Beautiful Soup 4 (<code>bs4</code>) to navigate the parse tree of the html and isolate the &ldquo;Scoring chart&rdquo; table.</li>
<li>Use and slightly modify a <a href="https://stackoverflow.com/a/48451104/4280216">very helpful function I found on StackOverflow</a> that converts an html table that uses <code>rowspan</code> (i.e., a single cell stretching over multiple rows) into a nested list representing a standard <em>m x n</em> array.</li>
<li>Write a function, <code>check_danceoff()</code>, that determines whether a table cell has the orange (eliminated) or light blue (survived the dance-off) color that denotes being in the dance-off.</li>
<li>Pipe everything together in a function <code>find_danceoffs()</code> that returns a tidy DataFrame in which each row corresponds to an observation of a single partnership in the dance-off for a single week.</li>
</ul>

<p>I&rsquo;ll append all the scraping code to the bottom of this post, but first a look at the final collection of the entire dance-off data set:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">df_all <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(columns<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;celebrity&#39;</span>,<span style="color:#e6db74">&#39;professional&#39;</span>,<span style="color:#e6db74">&#39;week&#39;</span>,<span style="color:#e6db74">&#39;series&#39;</span>])
<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">16</span>):
    series_str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;series_{}&#39;</span><span style="color:#f92672">.</span>format(x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    scd_url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;https://en.wikipedia.org/wiki/Strictly_Come_Dancing_({})&#39;</span><span style="color:#f92672">.</span>format(series_str)
    df_series <span style="color:#f92672">=</span> find_danceoffs(scd_url)
    df_series[<span style="color:#e6db74">&#39;series&#39;</span>] <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
    df_all <span style="color:#f92672">=</span> df_all<span style="color:#f92672">.</span>append(df_series)</code></pre></div>
<p>And then <code>df_all.tail()</code> gives (Wikipedia was incredibly fast to update with today&rsquo;s series 16 results!):</p>

<pre><code>|     | celebrity | professional | week | series |
|-----|-----------|--------------|------|--------|
| 309 | Lee       | Nadiya       | 3    | 16     |
| 310 | Charles   | Karen        | 4    | 16     |
| 311 | Katie     | Gorka        | 4    | 16     |
| 312 | Seann     | Katya        | 5    | 16     |
| 313 | Vick      | Graziano     | 5    | 16     |
</code></pre>

<p>And <code>df_describe()</code>:</p>

<pre><code>|        | celebrity | professional | week | series |
|--------|-----------|--------------|------|--------|
| count  | 314       | 314          | 314  | 314    |
| unique | 170       | 49           | 13   | 16     |
| top    | Mark      | Brendan      | 5    | 7      |
| freq   | 10        | 28           | 32   | 24     |
</code></pre>

<p>Turns out Brendan is the professional that&rsquo;s been in the dance-off more than anyone else.</p>


<figure>
    
        <img src="/strictly-come-data/images/bruno-no.gif" />
    
    
</figure>


<p>Rest of the code pasted below. And remember, keeeeeeeeeep data-ing!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> bs4
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> pd
<span style="color:#f92672">import</span> requests

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_danceoff</span>(ele):
    <span style="color:#66d9ef">if</span> ele<span style="color:#f92672">.</span>has_attr(<span style="color:#e6db74">&#39;style&#39;</span>):
        <span style="color:#75715e"># remove whitespace and ;</span>
        style <span style="color:#f92672">=</span> ele<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#39;style&#39;</span>]<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39; &#39;</span>,<span style="color:#e6db74">&#39;&#39;</span>)<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39;;&#39;</span>,<span style="color:#e6db74">&#39;&#39;</span>)
        <span style="color:#66d9ef">if</span> style <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;background:lightblue&#39;</span>:
            <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">elif</span> style <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;background:orange&#39;</span>:
            <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> False
    <span style="color:#66d9ef">elif</span> ele<span style="color:#f92672">.</span>has_attr(<span style="color:#e6db74">&#39;bgcolor&#39;</span>):
        bgcolor <span style="color:#f92672">=</span> ele<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#39;bgcolor&#39;</span>]
        <span style="color:#66d9ef">if</span> (bgcolor<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;orange&#39;</span>) <span style="color:#f92672">or</span> (bgcolor<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;lightblue&#39;</span>):
            <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> False
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> False

<span style="color:#75715e"># from https://stackoverflow.com/a/48451104/4280216</span>
<span style="color:#75715e"># use because of rowspans</span>
<span style="color:#75715e"># this function handles rowspans to return array with</span>
<span style="color:#75715e"># equal number of entries for each row</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># I modified so the value returned for each cell is</span>
<span style="color:#75715e"># cell_func(cell) rather than cell.get_text().</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">table_to_2d</span>(table_tag, cell_func):
    rowspans <span style="color:#f92672">=</span> []  <span style="color:#75715e"># track pending rowspans</span>
    rows <span style="color:#f92672">=</span> table_tag<span style="color:#f92672">.</span>find_all(<span style="color:#e6db74">&#39;tr&#39;</span>)

    <span style="color:#75715e"># first scan, see how many columns we need</span>
    colcount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> r, row <span style="color:#f92672">in</span> enumerate(rows):
        cells <span style="color:#f92672">=</span> row<span style="color:#f92672">.</span>find_all([<span style="color:#e6db74">&#39;td&#39;</span>, <span style="color:#e6db74">&#39;th&#39;</span>], recursive<span style="color:#f92672">=</span>False)
        <span style="color:#75715e"># count columns (including spanned).</span>
        <span style="color:#75715e"># add active rowspans from preceding rows</span>
        <span style="color:#75715e"># we *ignore* the colspan value on the last cell, to prevent</span>
        <span style="color:#75715e"># creating &#39;phantom&#39; columns with no actual cells, only extended</span>
        <span style="color:#75715e"># colspans. This is achieved by hardcoding the last cell width as 1. </span>
        <span style="color:#75715e"># a colspan of 0 means “fill until the end” but can really only apply</span>
        <span style="color:#75715e"># to the last cell; ignore it elsewhere. </span>
        colcount <span style="color:#f92672">=</span> max(
            colcount,
            sum(int(c<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;colspan&#39;</span>, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> cells[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> len(cells[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:]) <span style="color:#f92672">+</span> len(rowspans))
        <span style="color:#75715e"># update rowspan bookkeeping; 0 is a span to the bottom. </span>
        rowspans <span style="color:#f92672">+=</span> [int(c<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;rowspan&#39;</span>, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">or</span> len(rows) <span style="color:#f92672">-</span> r <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> cells]
        rowspans <span style="color:#f92672">=</span> [s <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> rowspans <span style="color:#66d9ef">if</span> s <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>]

    <span style="color:#75715e"># it doesn&#39;t matter if there are still rowspan numbers &#39;active&#39;; no extra</span>
    <span style="color:#75715e"># rows to show in the table means the larger than 1 rowspan numbers in the</span>
    <span style="color:#75715e"># last table row are ignored.</span>

    <span style="color:#75715e"># build an empty matrix for all possible cells</span>
    table <span style="color:#f92672">=</span> [[None] <span style="color:#f92672">*</span> colcount <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> rows]

    <span style="color:#75715e"># fill matrix from row data</span>
    rowspans <span style="color:#f92672">=</span> {}  <span style="color:#75715e"># track pending rowspans, column number mapping to count</span>
    <span style="color:#66d9ef">for</span> row, row_elem <span style="color:#f92672">in</span> enumerate(rows):
        span_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e"># how many columns are skipped due to row and colspans </span>
        <span style="color:#66d9ef">for</span> col, cell <span style="color:#f92672">in</span> enumerate(row_elem<span style="color:#f92672">.</span>find_all([<span style="color:#e6db74">&#39;td&#39;</span>, <span style="color:#e6db74">&#39;th&#39;</span>], recursive<span style="color:#f92672">=</span>False)):
            <span style="color:#75715e"># adjust for preceding row and colspans</span>
            col <span style="color:#f92672">+=</span> span_offset
            <span style="color:#66d9ef">while</span> rowspans<span style="color:#f92672">.</span>get(col, <span style="color:#ae81ff">0</span>):
                span_offset <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                col <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#75715e"># fill table data</span>
            rowspan <span style="color:#f92672">=</span> rowspans[col] <span style="color:#f92672">=</span> int(cell<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;rowspan&#39;</span>, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">or</span> len(rows) <span style="color:#f92672">-</span> row
            colspan <span style="color:#f92672">=</span> int(cell<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;colspan&#39;</span>, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">or</span> colcount <span style="color:#f92672">-</span> col
            <span style="color:#75715e"># next column is offset by the colspan</span>
            span_offset <span style="color:#f92672">+=</span> colspan <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#75715e"># define actual value to put in output table</span>
            value <span style="color:#f92672">=</span> cell_func(cell)
            <span style="color:#66d9ef">for</span> drow, dcol <span style="color:#f92672">in</span> product(range(rowspan), range(colspan)):
                <span style="color:#66d9ef">try</span>:
                    table[row <span style="color:#f92672">+</span> drow][col <span style="color:#f92672">+</span> dcol] <span style="color:#f92672">=</span> value
                <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">IndexError</span>:
                    <span style="color:#75715e"># rowspan or colspan outside the confines of the table</span>
                    <span style="color:#66d9ef">pass</span>

        <span style="color:#75715e"># update rowspan bookkeeping</span>
        rowspans <span style="color:#f92672">=</span> {c: s <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> c, s <span style="color:#f92672">in</span> rowspans<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> s <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>}

    <span style="color:#66d9ef">return</span> table

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_danceoffs</span>(url):
    r <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(url)
    soup <span style="color:#f92672">=</span> bs4<span style="color:#f92672">.</span>BeautifulSoup(r<span style="color:#f92672">.</span>text, <span style="color:#e6db74">&#39;html.parser&#39;</span>)
    <span style="color:#66d9ef">try</span>:
        chart_span <span style="color:#f92672">=</span> soup<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#39;span&#39;</span>,attrs<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;id&#39;</span>:<span style="color:#e6db74">&#39;Scoring_chart&#39;</span>})
        score_table <span style="color:#f92672">=</span> chart_span<span style="color:#f92672">.</span>findNext(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;table&#39;</span>)
        table_body <span style="color:#f92672">=</span> score_table<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#39;tbody&#39;</span>)

        text_array <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(table_to_2d(table_body, <span style="color:#66d9ef">lambda</span> c: c<span style="color:#f92672">.</span>get_text()<span style="color:#f92672">.</span>rstrip()))
        for_pd <span style="color:#f92672">=</span> {x[<span style="color:#ae81ff">0</span>]: x[<span style="color:#ae81ff">1</span>:] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> text_array<span style="color:#f92672">.</span>T}
        df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(for_pd)
        <span style="color:#75715e"># return df columns to original order and set &#39;Couple&#39; as index</span>
        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;Couple&#39;</span> <span style="color:#f92672">in</span> df<span style="color:#f92672">.</span>columns:
            df <span style="color:#f92672">=</span> df[text_array[<span style="color:#ae81ff">0</span>]]<span style="color:#f92672">.</span>set_index(<span style="color:#e6db74">&#34;Couple&#34;</span>)
        <span style="color:#75715e"># this handles inconsistent column name in Series 5 page</span>
        <span style="color:#66d9ef">elif</span> <span style="color:#e6db74">&#39;Team&#39;</span> <span style="color:#f92672">in</span> df<span style="color:#f92672">.</span>columns:
            df <span style="color:#f92672">=</span> df[text_array[<span style="color:#ae81ff">0</span>]]<span style="color:#f92672">.</span>set_index(<span style="color:#e6db74">&#34;Team&#34;</span>)
            df<span style="color:#f92672">.</span>index<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Couple&#34;</span>
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>

        danceoff_mask <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(table_to_2d(table_body, check_danceoff))
        <span style="color:#75715e"># convert to DataFrame with same columns and index as df</span>
        danceoff_df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(danceoff_mask[<span style="color:#ae81ff">1</span>:,<span style="color:#ae81ff">1</span>:], columns<span style="color:#f92672">=</span>df<span style="color:#f92672">.</span>columns, index<span style="color:#f92672">=</span>df<span style="color:#f92672">.</span>index)

        df_filter <span style="color:#f92672">=</span> df[danceoff_df]
        danceoffs <span style="color:#f92672">=</span> {}
        
        episode_list <span style="color:#f92672">=</span> []
        celeb_list <span style="color:#f92672">=</span> []
        pro_list <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> df_filter<span style="color:#f92672">.</span>columns:
            episode <span style="color:#f92672">=</span> df_filter[col]<span style="color:#f92672">.</span>dropna()<span style="color:#f92672">.</span>reset_index()
            <span style="color:#66d9ef">if</span> len(episode)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>:
                <span style="color:#75715e"># clean up episode name for output dict:</span>
                <span style="color:#66d9ef">if</span> col<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;1+2&#39;</span>:
                    clean_name <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
                <span style="color:#66d9ef">else</span>:
                    only_digits <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(c <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> col <span style="color:#66d9ef">if</span> c<span style="color:#f92672">.</span>isdigit())
                    clean_name <span style="color:#f92672">=</span> int(only_digits)
                
                <span style="color:#75715e"># split list of couples into celeb and pro first names</span>
                celebs <span style="color:#f92672">=</span> episode<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>Couple<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;&amp;&#39;</span>)[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>strip(), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
                pros <span style="color:#f92672">=</span> episode<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: x<span style="color:#f92672">.</span>Couple<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;&amp;&#39;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>strip(), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">for</span> celeb, pro <span style="color:#f92672">in</span> zip(celebs,pros):
                    episode_list<span style="color:#f92672">.</span>append(clean_name)
                    celeb_list<span style="color:#f92672">.</span>append(celeb)
                    pro_list<span style="color:#f92672">.</span>append(pro)

    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;problem with {}: {}&#39;</span><span style="color:#f92672">.</span>format(url, e))

    danceoffs_dict <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;week&#39;</span>: episode_list, <span style="color:#e6db74">&#39;celebrity&#39;</span>: celeb_list, <span style="color:#e6db74">&#39;professional&#39;</span>: pro_list}
    danceoffs <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(danceoffs_dict)
    <span style="color:#66d9ef">return</span> danceoffs</code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://awbirdsall.github.io/strictly-come-data/" >
    &copy; 2018 Strictly Come Data
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/strictly-come-data/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
